var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = TrackingTimers","category":"page"},{"location":"#TrackingTimers","page":"Home","title":"TrackingTimers","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [TrackingTimers]","category":"page"},{"location":"#TrackingTimers.TrackingTimer","page":"Home","title":"TrackingTimers.TrackingTimer","text":"TrackingTimer\n\nStores the results of @timed calls in a RemoteChannel to provide a distributed and thread-friendly way to collect timing results. Construct a TrackingTimer by t = TrackingTimer(). Populate it by TrackingTimers.@timeit or call t on a function (optionally providing a name) to obtain an InstrumentedFunction, which automatically populates t with timing results whenever it is called.\n\nTrackingTimer's support the Tables.jl row table interface. Call Tables.rows(t) to obtain a Vector{NamedTuple{(:name, :time, :gctime, :n_allocs, :bytes, :thread_id, :pid),Tuple{String,Float64,Float64,Int64,Int64,Int64,Int64}}} of the timing results obtained so far. Note that this uses a lock (via synchronize!) so it should be thread-safe albeit may cause contention if called from multiple threads simultaneously.\n\nExample\n\njulia> using Distributed\n\njulia> addprocs(2);\n\njulia> @everywhere using TrackingTimers\n\njulia> t = TrackingTimer()\nTrackingTimer: 1.09 s since creation (0% measured).\nNo entries.\n\njulia> @everywhere function f(i)\n           v = 1:(1000*myid())\n           return sum( v .^ (1/π))\n       end\n\njulia> f_inst = t(f) # instrument `f` with TrackingTimer `t`\n(::TrackingTimers.InstrumentedFunction{typeof(f)}) (generic function with 1 method)\n\njulia> pmap(f_inst, 1:10)\n10-element Vector{Float64}:\n 17056.850202253918\n 29106.968991882364\n 29106.968991882364\n 17056.850202253918\n 17056.850202253918\n 29106.968991882364\n 17056.850202253918\n 29106.968991882364\n 17056.850202253918\n 29106.968991882364\n\njulia> t\nTrackingTimer: 2.54 s since creation (0% measured).\n name   time   gcfraction  n_allocs    allocs    thread ID  proc ID \n────────────────────────────────────────────────────────────────\n f     0.00 s      0%         2  23.516 KiB          1        3\n f     0.00 s      0%         1  15.750 KiB          1        2\n f     0.00 s      0%         2  23.516 KiB          1        3\n f     0.00 s      0%         2  23.516 KiB          1        3\n f     0.00 s      0%         2  23.516 KiB          1        3\n f     0.00 s      0%         2  23.516 KiB          1        3\n f     0.00 s      0%         1  15.750 KiB          1        2\n f     0.00 s      0%         1  15.750 KiB          1        2\n f     0.00 s      0%         1  15.750 KiB          1        2\n f     0.00 s      0%         1  15.750 KiB          1        2\n\n\n\n\n\n","category":"type"},{"location":"#TrackingTimers.TrackingTimer-2","page":"Home","title":"TrackingTimers.TrackingTimer","text":"(t::TrackingTimer)(f, name=string(repr(f))) -> InstrumentedFunction\n\nInstruments f by the TrackingTimer t returning an InstrumentedFunction. This function can be used just like f, but whenever it is called it stores timing results in t.\n\n\n\n\n\n","category":"type"},{"location":"#TrackingTimers.synchronize!-Tuple{TrackingTimer}","page":"Home","title":"TrackingTimers.synchronize!","text":"synchronize!(t::TrackingTimer)\n\nPopulates t.results with any timing results collected so far. This uses a lock so it is safe to call from multiple threads, but may cause contention. Called automatically by Tables.rows(::TrackingTimer).\n\n\n\n\n\n","category":"method"},{"location":"#TrackingTimers.@timeit-Tuple{Any,Any,Any}","page":"Home","title":"TrackingTimers.@timeit","text":"@timeit(t::TrackingTimer, name, expr)\n\nEvaluates expr under @timed, storing the results in the TrackingTimer t.\n\n\n\n\n\n","category":"macro"}]
}
